(function() {
  var CHARS, CappedObject, L, LL, NodeBase, UUID, addId, arrize, cid, cids, colorize, colors, events, getTotalCids, glue, isArguments, isArray, isElement, isEmpty, isFunction, isString, levelStylesMapping, merge, node_ver, now, stringify, styles, stylize, util, _addContext, _addStaticContext, _ermit, _inmit, _remove, _wamit;
  var __hasProp = Object.prototype.hasOwnProperty, __slice = Array.prototype.slice, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  };
  events = require('events');
  util = require(process.binding('natives').util ? 'util' : 'sys');
  CappedObject = require('./CappedObject');
  Error.stackTraceLimit = 50;
  stringify = function(obj) {
    return JSON.stringify(obj, null, " ");
  };
  isEmpty = function(obj) {
    var key;
    if (isArray(obj) || isString(obj)) {
      return obj.length === 0;
    }
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      return false;
    }
    return true;
  };
  isElement = function(obj) {
    return obj && obj.nodeType === 1;
  };
  isArguments = function(obj) {
    return obj && obj.callee;
  };
  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };
  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };
  isArray = Array.isArray || function(obj) {
    return !!(obj && obj.concat && obj.unshift && !obj.callee);
  };
  /*
  # 
  # MERGE
  # a mixin function similar to _.extend but more powerful
  # it can also deal with non objects like functions
  #
  # @desc A cool merge function, that emits warnings
  #
  # @args obj, args..., last
  # the first argunment is the object we merge in,, which can also be a function, or better if the first obj is not an object we just set it to the merge value,
  # the last can be a boolean, in such case it is a switch for turning on and off warnings, on overwriting existing variables
  # logging of warnings is turned on by default
  #
  */
  module.exports.merge = module.exports.extend = module.exports.mixin = merge = function() {
    var args, initialProps, last, log, obj, prop, source, _i, _j, _len;
    obj = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), last = arguments[_i++];
    if (!(obj != null)) {
      throw new Error('merge: first parameter must not be undefined');
    }
    log = true;
    initialProps = {};
    for (prop in obj) {
      if (!__hasProp.call(obj, prop)) continue;
      initialProps[prop] = true;
    }
    if (typeof last !== 'boolean') {
      args.push(last);
    } else {
      log = last;
    }
    for (_j = 0, _len = args.length; _j < _len; _j++) {
      source = args[_j];
      if (obj === source) {
        return obj;
      }
      if ((typeof source !== 'object') && (source != null)) {
        if ((typeof obj !== 'object' && (obj != null)) || !isEmpty(obj)) {
          if (log) {
            this.warn("Object " + (stringify(obj) || obj.name || typeof obj) + " exists and will be overwritten with " + (stringify(source) || obj.name || typeof obj));
          }
        }
        obj = source;
      } else {
        for (prop in source) {
          if (!__hasProp.call(source, prop)) continue;
          if (initialProps[prop] != null) {
            if (log) {
              this.warn("property " + prop + " exists and value " + (stringify(obj[prop]) || typeof obj[prop]) + " will be overwritten with " + (stringify(source[prop]) || typeof obj[prop]));
              /*at #{new Error().stack}*/
            }
          }
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };
  L = 0;
  LL = {
    ALL: L++,
    LOG: L++,
    INFO: L++,
    WARN: L++,
    ERROR: L++
  };
  for (L in LL) {
    LL[LL[L]] = L;
  }
  /*
   @desc this is the mother of all Objects; a node Base Class with (logging and options, defaults)
    NodeBase is an EventEmitter 
  */
  NodeBase = (function() {
    __extends(NodeBase, events.EventEmitter);
    NodeBase.now = now;
    NodeBase.static = function(superClass) {
      var i, val, _ref;
      for (i in NodeBase) {
        if (!__hasProp.call(NodeBase, i)) continue;
        val = NodeBase[i];
        if ((_ref = superClass[i]) == null) {
          superClass[i] = NodeBase[i];
        }
      }
      return merge(superClass.options || (superClass.options = {}), superClass.defaults, false);
    };
    NodeBase.objdefaults = {
      logging: true,
      logLevel: 'ERROR',
      printLevel: true,
      printContext: true,
      useStack: true,
      emitLog: false
    };
    NodeBase.defaults = merge(NodeBase.objdefaults, {
      addToCollection: false,
      maxCap: 10000
    });
    NodeBase.options = NodeBase.defaults;
    NodeBase.merge = merge;
    NodeBase.mixin = merge;
    NodeBase.extend = merge;
    NodeBase.node_ver = node_ver;
    NodeBase.lookupId = function(id) {
      var _ref;
      if (this.name != null) {
        return (_ref = this.Cache) != null ? _ref.getId(id) : void 0;
      } else {
        return NodeBase != null ? NodeBase.getId(id) : void 0;
      }
    };
    NodeBase._remove = function(obj) {
      return _remove(obj);
    };
    NodeBase.getTotalIds = function() {
      if (this.name != null) {
        return cids[this.name] || 0;
      } else {
        return cids['NodeBase'] || 0;
      }
    };
    NodeBase.log = function() {
      if (this.options.logging && this._checkLogLevel('LOG')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['LOG'])));
      }
    };
    NodeBase.warn = function() {
      if (this.options.logging && this._checkLogLevel('WARN')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['WARN'])));
      }
    };
    NodeBase.info = function() {
      if (this.options.logging && this._checkLogLevel('INFO')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['INFO'])));
      }
    };
    NodeBase.error = function() {
      if (this.options.logging && this._checkLogLevel('ERROR')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['ERROR'])));
      }
    };
    NodeBase._addContext = function() {
      return _addStaticContext.apply(this, arguments);
    };
    NodeBase._checkLogLevel = function(level) {
      return LL[this.options.logLevel] <= LL[level];
    };
    NodeBase.emit = function() {
      return this._emitter.emit.apply(this, arguments);
    };
    NodeBase._emitter = new events.EventEmitter();
    NodeBase._emitter.on('error', function(err) {
      return console.log(stringify(err, null, " "));
    });
    NodeBase.ermit = function() {
      return _ermit.apply(this, arguments);
    };
    NodeBase.wamit = function() {
      return _wamit.apply(this, arguments);
    };
    NodeBase.inmit = function() {
      return _inmit.apply(this, arguments);
    };
    function NodeBase(opts, defaults) {
      this.inmit = __bind(this.inmit, this);
      this.wamit = __bind(this.wamit, this);
      this.ermit = __bind(this.ermit, this);
      this.error = __bind(this.error, this);
      this.info = __bind(this.info, this);
      this.warn = __bind(this.warn, this);
      this.log = __bind(this.log, this);      NodeBase.__super__.constructor.call(this);
      this.init(opts, defaults);
    }
    NodeBase.prototype.init = function(opts, defaults) {
      var self, _defaults, _ref, _ref2;
      self = this;
      _defaults = merge({}, {
        logging: true,
        logLevel: 'ERROR',
        printLevel: true,
        printContext: true,
        useStack: true,
        emitLog: false,
        autoId: true,
        autoUuid: true,
        cacheSize: 5
      }, this.defaults, defaults, false);
      this.options = merge(this.options || (this.options = {}), this.constructor.objdefaults, _defaults, opts, true);
      this.LOG_LEVELS = LL;
      this._checkLogLevel = function(level) {
        return LL[this.options.logLevel] <= LL[level];
      };
      if (this._id && this.options.autoId) {
        this.warn('overwriting _id');
      }
      this._id = this.options.autoId ? cid(this) : this._id;
      this._uuid = this.options.autoUuid ? UUID.uuid() : "";
      if (this.options.autoId) {
        this._getTotalIds = function() {
          return getTotalIds(this);
        };
      }
      if ((_ref = this.constructor) != null ? (_ref2 = _ref.options) != null ? _ref2.addToCollection : void 0 : void 0) {
        return addId(this);
      }
    };
    NodeBase.prototype.remove = function() {
      return _remove(this);
    };
    NodeBase.prototype._addContext = function() {
      return _addContext.apply(this, arguments);
    };
    /*  
    #
    # OBJECT LOGGING
    # error is special in that the first argument is interpretated as message, second as type, third, ... as arguments
    #
    #
    */
    NodeBase.prototype.log = function() {
      if (this.options.logging && this._checkLogLevel('LOG')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['LOG'])));
      }
    };
    NodeBase.prototype.warn = function() {
      if (this.options.logging && this._checkLogLevel('WARN')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['WARN'])));
      }
    };
    NodeBase.prototype.info = function() {
      if (this.options.logging && this._checkLogLevel('INFO')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['INFO'])));
      }
    };
    NodeBase.prototype.error = function() {
      if (this.options.logging && this._checkLogLevel('ERROR')) {
        return console.log(this._addContext.apply(this, __slice.call(arguments).concat(['ERROR'])));
      }
    };
    NodeBase.prototype.ermit = function() {
      return _ermit.apply(this, arguments);
    };
    NodeBase.prototype.wamit = function() {
      return _wamit.apply(this, arguments);
    };
    NodeBase.prototype.inmit = function() {
      return _inmit.apply(this, arguments);
    };
    return NodeBase;
  })();
  module.exports = NodeBase;
  module.exports.LOG_LEVELS = LL;
  module.exports.now = now = function() {
    return new Date().toUTCString();
  };
  node_ver = null;
  (function() {
    var matches, rex, ver;
    if (node_ver != null) {
      return node_ver;
    }
    ver = process.version;
    rex = /^v(\d+)\.(\d+)\.(\d+)/i;
    matches = ver.match(rex);
    if (matches == null) {
      throw "Unable to determine node version";
    }
    return node_ver = {
      major: ~~matches[1],
      minor: ~~matches[2],
      release: ~~matches[3]
    };
  })();
  module.exports.node_ver = node_ver;
  arrize = function(ary, from) {
    if (from == null) {
      from = 0;
    }
    return Array.prototype.slice.call(ary, from);
  };
  glue = function() {
    var f, oargs, obj;
    f = arguments[0], obj = arguments[1], oargs = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return function() {
      var iargs;
      iargs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return typeof f.apply === "function" ? f.apply(obj, oargs.concat(iargs)) : void 0;
    };
  };
  module.exports.glue = glue;
  /*
    Code taken from Robert Kieffer UUID
  
    Math.uuid.js (v1.4)
    http://www.broofa.com
    mailto:robert@broofa.com
  
    Copyright (c) 2010 Robert Kieffer
    Dual licensed under the MIT and GPL licenses.
  
  
    A UUID GENERATROR FUNCTION
    Private array of chars to use
   */
  CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
  UUID = {};
  UUID.uuid = function(len, radix) {
    var chars, i, r, uuid;
    if (radix == null) {
      radix = CHARS.length;
    }
    chars = CHARS;
    uuid = [];
    if (len != null) {
      for (i = 0; 0 <= len ? i <= len : i >= len; 0 <= len ? i++ : i--) {
        uuid[i] = chars[0 | Math.random() * radix];
      }
    } else {
      r;
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';
      for (i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random() * 16;
          uuid[i] = chars[i === 19 ? (r & 0x3) | 0x8 : r];
        }
      }
    }
    return uuid.join('');
  };
  module.exports.uuid = UUID.uuid;
  module.exports.UUID = UUID;
  cids = {};
  cid = function(obj) {
    if ((obj != null ? obj.constructor.name : void 0) != null) {
      return ++cids[obj.constructor.name] || (cids[obj.constructor.name] = 1);
    } else {
      return ++cids['NodeBase'] || (cids['NodeBase'] = 1);
    }
  };
  getTotalCids = function(obj) {
    if ((obj != null ? obj.constructor.name : void 0) != null) {
      return cids[obj.constructor.name] || 0;
    } else {
      return cids['NodeBase'] || 0;
    }
  };
  _remove = function(obj) {
    if (!obj._id) {
      module.exports.error("Obj to add has no propety _id, please turn on autoId or give the object an _id before passing it to super");
    }
    if ((obj != null ? obj.constructor.name : void 0) != null) {
      return obj.constructor.Cache.remove(obj);
    } else {
      return NodeBase.Cache.remove(obj);
    }
  };
  addId = function(obj) {
    var _base, _ref, _ref2;
    if (!obj._id) {
      module.exports.error("Obj to add has no propety _id, please turn on autoId or give the object an _id before passing it to super");
    }
    if ((obj != null ? obj.constructor.name : void 0) != null) {
      return ((_ref = (_base = obj.constructor).Cache) != null ? _ref : _base.Cache = new CappedObject(NodeBase.options.maxCap, obj.constructor)).addId(obj);
    } else {
      return ((_ref2 = NodeBase.Cache) != null ? _ref2 : NodeBase.Cache = new CappedObject(NodeBase.options.maxCap, NodeBase)).addId(obj);
    }
  };
  module.exports.cid = cid;
  styles = {
    'bold': [1, 22],
    'italic': [3, 23],
    'underline': [4, 24],
    'inverse': [7, 27],
    'white': [37, 39],
    'grey': [90, 39],
    'black': [30, 39],
    'blue': [34, 39],
    'cyan': [36, 39],
    'green': [32, 39],
    'magenta': [35, 39],
    'red': [31, 39],
    'yellow': [33, 39]
  };
  levelStylesMapping = {
    'WARN': 'magenta',
    'ERROR': 'red',
    'INFO': 'cyan',
    'LOG': 'green'
  };
  colorize = function(string, color) {
    var _ref;
    color = (_ref = levelStylesMapping[color]) != null ? _ref : levelStylesMapping[color] = color;
    return '\033[' + styles[color][0] + 'm' + string + '\033[' + styles[color][1] + 'm';
  };
  stylize = function(level) {
    var style;
    style = levelStylesMapping[level];
    if (style) {
      return '\033[' + styles[style][0] + 'm' + '[' + level + ']' + '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (typeof global !== "undefined" && global !== null) {
    colors = true;
  } else {
    stylize = function(level) {
      return '[' + level + '] ';
    };
    colorize = function(string, color) {
      return string;
    };
  }
  _addStaticContext = function() {
    var args, level, message, messageColor, stack, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), level = arguments[_i++];
    if ((level != null) && this.options.printLevel) {
      args.unshift(stylize(level));
    }
    stack = this.name + ' static';
    message = "[-- " + (now()) + " " + stack + "]  " + (args.join(' '));
    messageColor = " -- " + (now()) + "  " + (colorize('[ ' + stack + ']', level)) + " " + (args.join(' '));
    if (this.options.emitLog) {
      this._emitter.emit(level.toLowerCase(), {
        'message': message,
        'data': {
          'class': this.name,
          'args': args.slice(1, args.length)
        },
        'type': args[1]
      });
    }
    return messageColor;
  };
  _addContext = function() {
    var args, classAndFunction, fileNameAndLine, id, isnew, level, message, messageColor, reg, stack, stackArray, _i, _ref;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), level = arguments[_i++];
    if ((level != null) && this.options.printLevel) {
      args.unshift(stylize(level));
    }
    try {
      reg = new RegExp(/at\s(.*)\s\(.*[\/\\]([^\/\\\.]+\.js|[^\/\\\.]+\.coffee):(\d+):\d+/i);
      stackArray = new Error().stack.split(reg);
      if (this.options.useStack) {
        if (stackArray[17].indexOf('new') === -1 && ((_ref = stackArray[25]) != null ? _ref.indexOf('anonymous') : void 0) === -1) {
          stack = "" + stackArray[25] + " (" + stackArray[26] + ":[" + stackArray[27] + "])";
          fileNameAndLine = " in " + stackArray[26] + ":[" + stackArray[27] + "]";
          classAndFunction = "" + stackArray[25];
          isnew = false;
        } else {
          stack = "" + stackArray[17] + " (" + stackArray[18] + ":[" + stackArray[19] + "])";
          fileNameAndLine = " in " + stackArray[18] + ":[" + stackArray[19] + "]";
          classAndFunction = "" + stackArray[17];
          isnew = true;
        }
        if (stack.indexOf('inmit') !== -1 || stack.indexOf('wamit') !== -1 || stack.indexOf('ermit') !== -1) {
          if (!isnew) {
            stack = "[" + stackArray[29] + ": (" + stackArray[30] + ":[" + stackArray[31] + "])";
            fileNameAndLine = " in " + stackArray[30] + ":[" + stackArray[31] + "]";
            classAndFunction = "" + stackArray[29];
          } else {
            stack = "[" + stackArray[21] + ": (" + stackArray[22] + ":[" + stackArray[23] + "])";
            fileNameAndLine = " in " + stackArray[22] + ":[" + stackArray[23] + "]";
            classAndFunction = "" + stackArray[21];
          }
        }
      }
    } catch (e) {

    }
    if (stack == null) {
      stack = this.constructor.name;
    }
    if (this.options.autoId) {
      id = " id:" + this._id;
    }
    message = "-- " + (now()) + " [" + (classAndFunction + id) + "]  " + (args.join(' ')) + " " + fileNameAndLine;
    messageColor = "-- " + (now()) + " " + (colorize('[' + classAndFunction + id + ']', level)) + " " + (args.join(' ')) + " " + (colorize(fileNameAndLine, level));
    if (this.options.emitLog) {
      this.emit(level.toLowerCase(), {
        'message': message,
        'data': {
          'class': this.constructor.name,
          'id': this._id,
          'uuid': this._uuid,
          'args': args.slice(1, args.length)
        },
        'type': args[1]
      });
    }
    return messageColor;
  };
  _ermit = function(message, errObj) {
    var err, mes;
    if (errObj == null) {
      errObj = {};
    }
    mes = typeof message !== 'string' && (message.message != null) ? typeof message.message !== 'string' && (message.message.message != null) ? message.message.message : message.message : message;
    if (arguments.length < 1 || typeof mes !== 'string') {
      throw "Ermit needs at least one arguments: a message and an optional error Object";
    }
    /*
        message data
        - message
        -stack (the current stack)
        -err (the underlying errorObj)
      */
    err = {
      'stack': new Error().stack,
      'message': message,
      'err': errObj
    };
    this.error(mes);
    return this.emit('error', err);
  };
  _wamit = function(type, dataObj, message) {
    var mes, _ref;
    if (dataObj == null) {
      dataObj = {};
    }
    if (message == null) {
      message = "";
    }
    if (arguments.length < 1 || typeof message !== 'string' || typeof type !== 'string') {
      throw "wamit needs at least one arguments: a type, an optional Data Object and an optional message";
    }
    /*
        data
        dataOb   
        - message
      */
    if (typeof dataObj === "string") {
      message = dataObj;
    }
    mes = message === "" ? type : message;
    if ((_ref = dataObj.message) == null) {
      dataObj.message = "";
    }
    if (typeof dataObj.message === "string") {
      dataObj.message += ' - ' + mes;
    }
    this.warn(mes);
    return this.emit(type, dataObj);
  };
  _inmit = function(type, dataObj, message) {
    var mes;
    if (dataObj == null) {
      dataObj = {};
    }
    if (message == null) {
      message = "";
    }
    if (arguments.length < 1 || typeof message !== 'string' || typeof type !== 'string') {
      throw "inmit needs at least one arguments: a type, an optional Data Object and an optional message";
    }
    if (typeof dataObj === "string") {
      message = dataObj;
    }
    mes = message === "" ? type : message;
    /*
        data
        dataOb   
        - message
      */
    if (dataObj.message) {
      dataObj.message + " - ";
    } else {
      "";
    }
    dataObj.message += mes;
    this.info(mes);
    return this.emit(type, dataObj);
  };
}).call(this);
