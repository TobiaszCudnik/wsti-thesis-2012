#props = require './props'

Property = exports.Property
AsyncProperty = exports.AsyncProperty
Signal = exports.Signal
PropertiesObject = exports.PropertiesObject
SignalsObject = exports.SignalsObject
expect = if require?
    require('sinon-expect').enhance(expect, sinon, 'was')
else    SinonExpect.enhance window?.expect, sinon, 'was'
#_ = require 'underscore'
property = -> new Property arguments[0], arguments[1], arguments[2]
async_property = -> new AsyncProperty arguments[0], arguments[1], arguments[2]
signal = -> new Signal arguments[0], arguments[1], arguments[2]

describe 'Properties', ->
    obj = klass = null

    describe 'basics', ->
        beforeEach ->
            class klass
                property 'foo', @, 'bar'
                #				@property 'foo', 'bar'

                constructor: ->
            obj = new klass

        it 'should work like getter', ->
        #        expect( obj.foo() ).to.eql 'bar'
            expect(obj.foo()).to.eql 'bar'

        it 'should work like a setter', ->
            obj.foo 'baz'
            expect(obj.foo()).to.eql 'baz'

    describe 'mixin basics', ->
        beforeEach ->
            class klass extends PropertiesObject
                @property 'foo', 'bar'

                constructor: ->

            obj = new klass

        it 'should work like getter', ->
        #        expect( obj.foo() ).to.eql 'bar'
            expect(obj.foo()).to.eql 'bar'

        it 'should work like a setter', ->
            obj.foo 'baz'
            expect(obj.foo()).to.eql 'baz'

    describe 'custom funcs', ->
        beforeEach ->
            class klass
                property 'foo', @,
                    set: (set, val) ->
                        set val.replace /a/, 'b'

                property 'bar', @,
                    init: (set) -> set 'bar'
                    get: (get) -> return get().replace /a/, 'b'

                property 'baz', @,
                    init: (set) -> set null
                    get: (get) -> return get().replace /z/, 'b'
                    set: (set, val) ->
                        set val.replace /a/, 'b'

                constructor: ->
            obj = new klass

        it 'should support custom setter', ->
            obj.foo 'baz'
            expect(obj.foo()).to.eql 'bbz'

        it 'should support custom getter', ->
            expect(obj.bar()).to.eql 'bbr'

        it 'should support custom getter and setter', ->
            obj.baz 'baz'
            expect(obj.baz()).to.eql 'bbb'

describe 'Signals', ->
    scope = obj = klass = spy = null

    describe 'basics', ->
        beforeEach ->
            scope = {
                bar1_on: sinon.spy()
                bar2_on: sinon.spy()
                bar2_init: sinon.spy()
                baz_init: sinon.spy()
            }
            class klass

                signal 'foo', @

                signal 'bar1', @, on: scope.bar1_on

                signal 'bar2', @,
                    on: scope.bar2_on
                    init: scope.bar2_init

                signal 'baz', @, scope.baz_init

                on: ->
                emit: ->

            obj = new klass
            # mock
            sinon.stub obj
            # general spy
            spy = sinon.spy()
            obj.foo.restore()
            obj.bar1.restore()
            obj.bar2.restore()
            obj.baz.restore()
            # init signals (needs to be done after mocking)
            obj.baz().init()
            obj.bar1().init()
            obj.bar2().init()

        it 'should define signal', ->
            expect( obj.foo.constructor ).to.equal Signal

        it 'should init signals', ->
            expect( scope.baz_init ).was.called()

        it 'should emit events', ->
            obj.foo ->
            expect(obj.emit).was.calledWith 'foo'

        it 'should emit events with params', ->
            obj.foo 'param1', ->
            expect(obj.emit).was.calledWith 'foo', 'param1'

        it 'should bind to events', ->
            obj.foo().on ->
            expect(obj.on).was.calledWith 'foo'

        it 'should support initial listener', ->
            expect( obj.on ).was.calledWith 'bar1'

        it 'should init signals with initial listener', ->
            expect( obj.on ).was.calledWith 'bar2'
            expect( scope.bar2_init ).was.called()

        describe 'aop', ->
            it 'should allow to bind to a before event', ->
                obj.foo().before ->
                expect(obj.on).was.calledWith 'before-foo'

            it 'should allow to bind to an after event', ->
                obj.foo().after ->
                expect(obj.on).was.calledWith 'after-foo'

    describe 'mixin', ->
        spies = null
        beforeEach ->
            spies = init: sinon.spy()
            class klass extends SignalsObject
                @signal 'foo'

                @signal 'bar1', on: scope.bar1_on

                @signal 'bar2',
                    on: scope.bar2_on
                    init: scope.bar2_init

                @signal 'baz', scope.baz_init

                on: ->
                emit: ->

            obj = new klass
            # mock
            sinon.stub obj
            # general spy
            spy = sinon.spy()
            obj.foo.restore()
            obj.bar1.restore()
            obj.bar2.restore()
            obj.baz.restore()

        it 'should auto init signals', ->
            obj.initSignals()
            expect( scope.baz_init ).was.called()
            expect( scope.bar2_init ).was.called()

        describe 'basics', ->
            beforeEach ->
                # init signals (needs to be done after mocking)
                obj.baz().init()
                obj.bar1().init()
                obj.bar2().init()

            # COPY - PASTE FROM basics

            it 'should define signal', ->
                expect( obj.foo.constructor ).to.equal Signal

            it 'should init signals', ->
                expect( scope.baz_init ).was.called()

            it 'should emit events', ->
                obj.foo ->
                expect(obj.emit).was.calledWith 'foo'

            it 'should emit events with params', ->
                obj.foo 'param1', ->
                expect(obj.emit).was.calledWith 'foo', 'param1'

            it 'should bind to events', ->
                obj.foo().on ->
                expect(obj.on).was.calledWith 'foo'

            it 'should support initial listener', ->
                expect( obj.on ).was.calledWith 'bar1'

            it 'should init signals with initial listener', ->
                expect( obj.on ).was.calledWith 'bar2'
                expect( scope.bar2_init ).was.called()

            describe 'aop', ->
                it 'should allow to bind to a before event', ->
                    obj.foo().before ->
                    expect(obj.on).was.calledWith 'before-foo'

                it 'should allow to bind to an after event', ->
                    obj.foo().after ->
                    expect(obj.on).was.calledWith 'after-foo'

            # END OF COPY - PASTE FROM basics

    # TODO needs asynceventemitter
#    descript 'acceptance', ->
#        beforeEach ->
#            class klass extends AsyncEventEmitter
#
#                @signal 'foo'
#
#                @signal 'bar', on: (next, ret) -> next ++ret
#
#                constructor: ->
#
#            obj = new klass
#            # mock
#            sinon.stub obj
#            obj.foo.restore()
#            obj.bar.restore()
#            obj.baz.restore()
#
#        it 'should emit params', ->
#            spy = sinon.spy()
#            obj.foo().on spy
#            params = ['foo', 'bar']
#            obj.foo params[0], params[1], ->
#            # skip callback and ret value in the assertion
#            expect( spy.getCall(0).args[3..4] )
#                .to.eql params

#describe 'AsyncProperties', ->
#	obj = klass = null
#
#	describe 'basics', ->
#		beforeEach ->
#			class klass
#				property 'foo', @,
#					init: -> 'bar'
#					set: (set, val, next) ->
#						setTimeout ->
#							set val
#							do next
#
#				constructor: ->
#			obj = new klass
#
#		it 'should work like a getter', ->
#	#        expect( obj.foo() ).to.eql 'bar'
#			debugger
#			obj.foo().should.eql 'bar'
#
#		it 'should work like setter', ->
#			obj.foo 'baz'
#			obj.foo().should.eql 'baz'