exports ?= {}

class exports.Property
	value: undefined,
	getter_args_length_: 0,
	@new: -> new exports.Property arguments[0], arguments[1], arguments[2]

	constructor: (prop, @obj, funcs) ->
		name = @setName prop
		return if obj[ name ]

		getter_args_length_ = @getter_args_length_

		set = @setObjectValue name
		get = @getObjectValue name

		funcs = @parseFuncs funcs

		# prepare init
		init = if funcs?['init']
			@preparePassedFunction funcs['init'], set
		else
			@getInit set, name
		# prepare getter
		getter = if funcs?['get']
			@preparePassedFunction funcs['get'], get
		else
			@getGetter get
		# prepare setter
		setter = if funcs?['set']
			@preparePassedFunction funcs['set'], set
		else
			@getSetter set

		# attach to the prototype
		obj.prototype[ name ] = (value) ->
			@initialize.call @, name, init

			# regular getter/setter code
			if arguments.length > getter_args_length_
			#                console.log 'set property val'
				return setter.apply @, arguments
			else
			#                console.log 'get property val'
				return getter.apply @, arguments

		obj.prototype[ name ].init = init
		obj.prototype[ name ].set = set
		obj.prototype[ name ].name = name

	parseFuncs: (funcs) ->
		# prepare default value
		if funcs?.constructor is String
			def_value = funcs
			funcs = init: (set) -> set.call @, def_value
		funcs

	initialize: (name, init) ->
		# init property when undefined
		if @[ name + '_' ] is undefined
		#                console.log 'setup property val'
			@[ name + '_' ] = init.apply @

	setObjectValue: (property) ->
		(v) -> @[ property + '_' ] = v
	getObjectValue: (property, init) ->
		-> @[ property + '_' ]

	preparePassedFunction: (fn, method) ->
		(args...) ->
			args.unshift method.bind @
			fn.apply @, args

	setName: (name) ->
		@name = name
		@getName()

	getName: -> @name
	getGetter: (get) -> get
	getSetter: (set) -> set
	getInit: (set) ->
		-> set.call @, null
# TODO set setter, getter, int

#class exports.AsyncProperty extends exports.Property
#	getter_args_length_: 1,
#	@new: -> new exports.AsyncProperty arguments[0], arguments[1], arguments[1]
#
#	getSetter: (prop_value) ->
#		throw new Error 'setter needed for AsyncProperty'
#	getGetter: (prop_value) ->
#		throw new Error 'getter needed for AsyncProperty'

# TODO init (DONE?)
# TODO async init?
# TODO wrap init to always set a signal flag
class exports.Signal extends exports.Property
	getter_args_length_: 0,

	constructor: (prop, obj, funcs) ->
		name = @getName prop
		# allow to just bind to a existing signal by declaration
		if obj[ name ] and funcs?.on and not funcs?.init
			obj[ name ]().on funcs.on
		else
			super prop, obj, funcs

	# empty override
	initialize: ->

	parseFuncs: (funcs) ->
		# prepare default value
		if funcs?.constructor is Function
			init = funcs
			funcs = { init }
		if funcs?.on
			old_init = func.init
			signal = @getName()
			func.init = (set, next) ->
				@[ signal ]().on funcs.on
				next?()

		super funcs

	# Get signal obj. you can bind on it.
	getGetter: (get) ->
		-> get.call @
	# Fake value init.
	getInit: null
	# Trigger a signal, passing params and the callback.
	getSetter: (set) ->
		(arg1, arg2, next) ->
			set.apply @, arguments

	# Return function triggering the signal.
	setObjectValue: (property) ->
		(args...) ->
			args.unshift property
			@emit.apply @, args

	# Return a signal obj, for nor with just a binding function.
	getObjectValue: (property, init) ->
		(next) ->
		# TODO expose more methods, cache bindings (?)
			on: => @on property, next
			once: => @once property, next
			before: => @once 'before-' + property, next
			after: => @bind 'after-' + property, next
			init: (next) =>
				prop = @[ property ]
				prop.init.call @, prop.set.bind(@), next

# Inheritance helpers. Extending will also work for constructors (recursive).

class exports.PropertiesObject
	@property: ->
		new exports.Property arguments[0], @, arguments[1]

class exports.SignalsObject
	@signal: ->
		new exports.Signal arguments[0], @, arguments[1]

	getSignals: ->
		for prop of @
#			continue if not @hasOwnProperty prop
			continue if @[prop].constructor isnt Signal
			prop

	initSignals: (include, skip, next) ->
		for prop of @getSignals()
			continue if not @[prop].init
			continue if include and prop not in include
			continue if skip and prop not in skip
			@[prop].init.call @, next