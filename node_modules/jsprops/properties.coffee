exports ?= {}

class exports.Property
    value: undefined,
    getter_args_length_: 0,
    @new: -> new exports.Property arguments[0], arguments[1], arguments[2]

    constructor: (prop, obj, funcs) ->
        name = @setName prop
        return if obj[ name ]

        getter_args_length_ = @getter_args_length_

        set = @setObjectValue name
        get = @getObjectValue name

        funcs = @parseFuncs funcs

        # prepare init
        init = if funcs?['init']
            @preparePassedFunction funcs['init'], set
        else
            @getInit set, name
        # prepare getter
        getter = if funcs?['get']
            @preparePassedFunction funcs['get'], get
        else
            @getGetter get
        # prepare setter
        setter = if funcs?['set']
            @preparePassedFunction funcs['set'], set
        else
            @getSetter set

        initialize = @initialize
        # attach to the prototype
        obj.prototype[ name ] = (value) ->
            initialize?.call @, name, init

            # regular getter/setter code
            if arguments.length > getter_args_length_
            #                console.log 'set property val'
                return setter.apply @, arguments
            else
            #                console.log 'get property val'
                return getter.apply @, arguments

        obj.prototype[ name ].init = init
        obj.prototype[ name ].set = set
        obj.prototype[ name ].name = name
        obj.prototype[ name ].constructor = @constructor

    parseFuncs: (funcs) ->
        # prepare default value
        if funcs?.constructor is String
            def_value = funcs
            funcs = init: (set) -> set.call @, def_value
        funcs

    initialize: (name, init) ->
        # init property when undefined
        if @[ name + '_' ] is undefined
        #                console.log 'setup property val'
            @[ name + '_' ] = init.apply @

    setObjectValue: (property) ->
        (v) -> @[ property + '_' ] = v
    getObjectValue: (property) ->
        -> @[ property + '_' ]

    preparePassedFunction: (fn, method) ->
        (args...) ->
            args.unshift method.bind @
            fn.apply @, args

    setName: (name) ->
        @name = name
        @getName()

    getName: -> @name
    getGetter: (get) -> get
    getSetter: (set) -> set
    getInit: (set) ->
        -> set.call @, null
# TODO set setter, getter, int

#class exports.AsyncProperty extends exports.Property
#	getter_args_length_: 1,
#	@new: -> new exports.AsyncProperty arguments[0], arguments[1], arguments[1]
#
#	getSetter: (prop_value) ->
#		throw new Error 'setter needed for AsyncProperty'
#	getGetter: (prop_value) ->
#		throw new Error 'getter needed for AsyncProperty'

# TODO init (DONE?)
# TODO async init?
# TODO wrap init to always set a signal flag
class exports.Signal extends exports.Property
    getter_args_length_: 0,

    constructor: (prop, obj, funcs) ->
        name = @getName prop
        # allow to just bind to a existing signal by declaration
        if obj[ name ] and funcs?.on and not funcs?.init
            obj[ name ]().on funcs.on
        else
            super prop, obj, funcs

    # empty override
    initialize: null

    parseFuncs: (funcs) ->
        # prepare default value
        if funcs?.constructor is Function
            init = funcs
            funcs = { init }
        if funcs?.on
            old_init = funcs.init
            signal = @getName()
            funcs.init = (set, next) ->
                @[ signal ]().on funcs.on
                if old_init
                    old_init set, next

        super funcs

    # Get signal obj. you can bind on it.
    getGetter: (get) ->
        -> get.call @
    # Fake value init.
    getInit: -> null
    # Trigger a signal, passing params and the callback.
    getSetter: (set) ->
        (arg1, arg2, next) ->
            set.apply @, arguments

    # Return function triggering the signal.
    setObjectValue: (property) ->
        (args...) ->
            args.unshift property
            @emit.apply @, args

    # Return a signal obj, with some event functions.
    getObjectValue: (property) -> ->
    # TODO expose more methods, cache bindings (?)
        on: (handler) => @on property, handler
        once: (handler) => @once property, handler
        before: (handler) =>
            console.log 'before-' + property
            @on 'before-' + property, handler
        after: (handler) => @on 'after-' + property, handler
        # shorthand to calling `prop.init.call @`
        init: (next) =>
            prop = @[ property ]
            prop.init.call @, prop.set.bind(@), next

# Inheritance helpers. Extending will also work for constructors (recursive).

class exports.PropertiesObject
    @property: ->
        new exports.Property arguments[0], @, arguments[1]

class exports.SignalsObject
    @signal: ->
        new exports.Signal arguments[0], @, arguments[1]

    getSignals: ->
        for prop of @
#			continue if not @hasOwnProperty prop
            continue if @[prop].constructor isnt exports.Signal
            prop

    initSignals: (include, skip, next) ->
        for prop in @getSignals()
            continue if not @[prop].init
            continue if include and prop not in include
            continue if skip and prop not in skip
            @[prop].init.call @, next
